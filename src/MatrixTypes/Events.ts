/**
 * Copyright (C) 2023 Gnuxie <Gnuxie@protonmail.com>
 * All rights reserved.
 *
 * This file is modified and is NOT licensed under the Apache License.
 * This modified file incorperates work from matrix-spec
 * https://github.com/matrix-org/matrix-spec
 * which included the following license notice:
Copyright 2018 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 *
 * However, this file is modified and the modifications in this file
 * are NOT distributed, contributed, committed, or licensed under the Apache License.
 */

import { Static, StaticDecode, TSchema, Type } from '@sinclair/typebox';
import {
  StringEventID,
  StringRoomID,
  StringUserID,
} from './StringlyTypedMatrix';

const TContent = Type.Unknown();

export type Event<Content extends TSchema = typeof TContent> = Static<
  ReturnType<typeof Event<Content>>
>;
export const Event = <Content extends TSchema>(Content: Content) =>
  Type.Object({
    content: Content,
    type: Type.String({
      description:
        "The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type'",
    }),
  });

export type UnsignedData = Static<typeof UnsignedData>;
export const UnsignedData = Type.Object({
  age: Type.Optional(
    Type.Number({
      description:
        'The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.',
      format: 'int64',
      example: 1567437,
    })
  ),
  redacted_because: Type.Optional(Type.Unknown()),
  transaction_id: Type.Optional(
    Type.String({
      description:
        'The client-supplied [transaction ID](/client-server-api/#transaction-identifiers), for example, provided via\n`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,\nif the client being given the event is the same one which sent it.\n',
    })
  ),
  prev_content: Type.Optional(Type.Unknown()),
});

export type SyncRoomEvent<Content extends TSchema = typeof TContent> = Static<
  ReturnType<typeof SyncRoomEvent<Content>>
>;
export const SyncRoomEvent = <Content extends TSchema>(Content: Content) =>
  Type.Composite([
    Event(Content),
    Type.Object({
      event_id: StringEventID,
      sender: StringUserID,
      origin_server_ts: Type.Number({
        description:
          'Timestamp in milliseconds on originating homeserver when this event was sent.',
        format: 'int64',
      }),
      unsigned: Type.Optional(UnsignedData),
    }),
  ]);

export type RoomEvent<Content extends TSchema = typeof TContent> = StaticDecode<
  ReturnType<typeof RoomEvent<Content>>
>;
export const RoomEvent = <Content extends TSchema>(Content: Content) =>
  Type.Composite([
    SyncRoomEvent(Content),
    Type.Object({
      room_id: StringRoomID,
    }),
  ]);

const StateKey = Type.Object({
  state_key: Type.String({
    description:
      "A unique key which defines the overwriting semantics for this piece of room state. This value is often a zero-length string. The presence of this key makes this event a State Event.\nState keys starting with an `@` are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user's ID as the state key MUST only be set by that user.",
  }),
});

export type SyncStateEvent<Content extends TSchema = typeof TContent> =
  StaticDecode<ReturnType<typeof SyncStateEvent<Content>>>;
export const SyncStateEvent = <Content extends TSchema>(Content: Content) =>
  Type.Composite([SyncRoomEvent(Content), StateKey]);

export type StateEvent<Content extends TSchema = typeof TContent> =
  StaticDecode<ReturnType<typeof StateEvent<Content>>>;
export const StateEvent = <Content extends TSchema>(Content: Content) =>
  Type.Composite([RoomEvent(Content), StateKey]);

export type StrippedStateEvent = StaticDecode<typeof StrippedStateEvent>;
export const StrippedStateEvent = Type.Object({
  content: Type.Unknown(),
  state_key: Type.String({ description: 'The `state_key` for the event.' }),
  type: Type.String({ description: 'The `type` for the event.' }),
  sender: StringUserID,
});
